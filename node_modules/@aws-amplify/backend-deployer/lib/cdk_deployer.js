import stream from 'stream';
import readline from 'readline';
import { AmplifyUserError, CDKContextKey, } from '@aws-amplify/platform-core';
import { dirname } from 'path';
/**
 * Commands that can be invoked
 */
var InvokableCommand;
(function (InvokableCommand) {
    InvokableCommand["DEPLOY"] = "deploy";
    InvokableCommand["DESTROY"] = "destroy";
    InvokableCommand["SYNTH"] = "synth";
})(InvokableCommand || (InvokableCommand = {}));
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    relativeCloudAssemblyLocation = '.amplify/artifacts/cdk.out';
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
    }
    /**
     * Invokes cdk deploy command
     */
    deploy = async (backendId, deployProps) => {
        const cdkCommandArgs = [];
        if (backendId.type === 'sandbox') {
            cdkCommandArgs.push('--hotswap-fallback');
            cdkCommandArgs.push('--method=direct');
            if (deployProps?.secretLastUpdated) {
                cdkCommandArgs.push('--context', `secretLastUpdated=${deployProps.secretLastUpdated.getTime()}`);
            }
        }
        if (deployProps?.profile) {
            cdkCommandArgs.push('--profile', deployProps.profile);
        }
        // first synth with the backend definition but suppress any errors.
        // We want to show errors from the TS compiler rather than the ESBuild as
        // TS errors are more relevant (Library validations are type reliant).
        const startTime = Date.now();
        let synthError = undefined;
        try {
            await this.tryInvokeCdk(InvokableCommand.SYNTH, backendId, this.getAppCommand(), cdkCommandArgs.concat('--quiet') // don't print the CFN template to stdout
            );
        }
        catch (e) {
            synthError = e;
        }
        // CDK prints synth time in seconds rounded to 2 decimal places. Here we duplicate that behavior.
        const synthTimeSeconds = Math.floor((Date.now() - startTime) / 10) / 100;
        // then run type checks
        await this.invokeTsc(deployProps);
        // If somehow TSC was successful but synth wasn't, we now throw to surface the synth error
        if (synthError) {
            throw synthError;
        }
        // then deploy with the cloud assembly that was generated during synth
        const deployResult = await this.tryInvokeCdk(InvokableCommand.DEPLOY, backendId, this.relativeCloudAssemblyLocation, cdkCommandArgs);
        return {
            deploymentTimes: {
                synthesisTime: synthTimeSeconds,
                totalTime: synthTimeSeconds + (deployResult?.deploymentTimes?.totalTime || 0),
            },
        };
    };
    /**
     * Invokes cdk destroy command
     */
    destroy = async (backendId, destroyProps) => {
        const cdkCommandArgs = ['--force'];
        if (destroyProps?.profile) {
            cdkCommandArgs.push('--profile', destroyProps.profile);
        }
        return this.tryInvokeCdk(InvokableCommand.DESTROY, backendId, this.getAppCommand(), cdkCommandArgs);
    };
    /**
     * Wrapper for the child process executor. Helps in unit testing as node:test framework
     * doesn't have capabilities to mock exported functions like `execa` as of right now.
     */
    executeCommand = async (commandArgs, options = { printStdout: true }) => {
        // We let the stdout and stdin inherit and streamed to parent process but pipe
        // the stderr and use it to throw on failure. This is to prevent actual
        // actionable errors being hidden among the stdout. Moreover execa errors are
        // useless when calling CLIs unless you made execa calling error.
        let aggregatedStderr = '';
        const aggregatorStderrStream = new stream.Writable();
        aggregatorStderrStream._write = function (chunk, encoding, done) {
            aggregatedStderr += chunk;
            done();
        };
        const childProcess = this.packageManagerController.runWithPackageManager(commandArgs, process.cwd(), {
            stdin: 'inherit',
            stdout: 'pipe',
            stderr: 'pipe',
            // Piping the output by default strips off the color. This is a workaround to
            // preserve the color being piped to parent process.
            extendEnv: true,
            env: { FORCE_COLOR: '1' },
        });
        childProcess.stderr?.pipe(aggregatorStderrStream);
        if (options?.printStdout) {
            childProcess.stdout?.pipe(process.stdout);
        }
        const cdkOutput = { deploymentTimes: {} };
        if (childProcess.stdout) {
            await this.populateCDKOutputFromStdout(cdkOutput, childProcess.stdout);
        }
        try {
            await childProcess;
            return cdkOutput;
        }
        catch (error) {
            // swallow execa error if the cdk cli ran and produced some stderr.
            // Most of the time this error is noise(basically child exited with exit code...)
            // bubbling this up to customers add confusion (Customers don't need to know we are running IPC calls
            // and their exit codes printed while sandbox continue to run). Hence we explicitly don't pass error in the cause
            // rather throw the entire stderr for clients to figure out what to do with it.
            // However if the cdk process didn't run or produced no output, then we have nothing to go on with. So we throw
            // this error to aid in some debugging.
            if (aggregatedStderr.trim()) {
                throw new Error(aggregatedStderr);
            }
            else {
                throw error;
            }
        }
    };
    getAppCommand = () => this.packageManagerController.getCommand([
        'tsx',
        this.backendLocator.locate(),
    ]);
    invokeTsc = async (deployProps) => {
        if (!deployProps?.validateAppSources) {
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--showConfig',
                '--project',
                dirname(this.backendLocator.locate()),
            ], { printStdout: false });
        }
        catch (error) {
            // If we cannot load ts config, turn off type checking
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--noEmit',
                '--skipLibCheck',
                // pointing the project arg to the amplify backend directory will use the tsconfig present in that directory
                '--project',
                dirname(this.backendLocator.locate()),
            ]);
        }
        catch (err) {
            throw new AmplifyUserError('SyntaxError', {
                message: 'TypeScript validation check failed.',
                resolution: 'Fix the syntax and type errors in your backend definition.',
            }, err instanceof Error ? err : undefined);
        }
    };
    /**
     * calls invokeCDK and wrap it in a try catch
     */
    tryInvokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        try {
            return await this.invokeCdk(invokableCommand, backendId, appArgument, additionalArguments);
        }
        catch (err) {
            throw this.cdkErrorMapper.getAmplifyError(err);
        }
    };
    /**
     * Executes a CDK command
     */
    invokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        // Basic args
        const cdkCommandArgs = [
            'cdk',
            invokableCommand.toString(),
            // This is unfortunate. CDK writes everything to stderr without `--ci` flag and we need to differentiate between the two.
            // See https://github.com/aws/aws-cdk/issues/7717 for more details.
            '--ci',
            '--app',
            appArgument,
            '--all',
            '--output',
            this.relativeCloudAssemblyLocation,
        ];
        // Add context information if available
        cdkCommandArgs.push('--context', `${CDKContextKey.BACKEND_NAMESPACE}=${backendId.namespace}`, '--context', `${CDKContextKey.BACKEND_NAME}=${backendId.name}`);
        if (backendId.type !== 'sandbox') {
            cdkCommandArgs.push('--require-approval', 'never');
        }
        cdkCommandArgs.push('--context', `${CDKContextKey.DEPLOYMENT_TYPE}=${backendId.type}`);
        if (additionalArguments) {
            cdkCommandArgs.push(...additionalArguments);
        }
        return await this.executeCommand(cdkCommandArgs);
    };
    populateCDKOutputFromStdout = async (output, stdout) => {
        const regexTotalTime = /✨ {2}Total time: (\d*\.*\d*)s.*/;
        const regexSynthTime = /✨ {2}Synthesis time: (\d*\.*\d*)s/;
        const reader = readline.createInterface(stdout);
        for await (const line of reader) {
            if (line.includes('✨')) {
                // Good chance that it contains timing information
                const totalTime = line.match(regexTotalTime);
                if (totalTime && totalTime.length > 1 && !isNaN(+totalTime[1])) {
                    output.deploymentTimes.totalTime = +totalTime[1];
                }
                const synthTime = line.match(regexSynthTime);
                if (synthTime && synthTime.length > 1 && !isNaN(+synthTime[1])) {
                    output.deploymentTimes.synthesisTime = +synthTime[1];
                }
            }
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxRQUFRLE1BQU0sVUFBVSxDQUFDO0FBYWhDLE9BQU8sRUFDTCxnQkFBZ0IsRUFFaEIsYUFBYSxHQUNkLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQjs7R0FFRztBQUNILElBQUssZ0JBSUo7QUFKRCxXQUFLLGdCQUFnQjtJQUNuQixxQ0FBaUIsQ0FBQTtJQUNqQix1Q0FBbUIsQ0FBQTtJQUNuQixtQ0FBZSxDQUFBO0FBQ2pCLENBQUMsRUFKSSxnQkFBZ0IsS0FBaEIsZ0JBQWdCLFFBSXBCO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sV0FBVztJQU1IO0lBQ0E7SUFDQTtJQVBGLDZCQUE2QixHQUFHLDRCQUE0QixDQUFDO0lBQzlFOztPQUVHO0lBQ0gsWUFDbUIsY0FBOEIsRUFDOUIsY0FBOEIsRUFDOUIsd0JBQWtEO1FBRmxELG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUEwQjtJQUNsRSxDQUFDO0lBQ0o7O09BRUc7SUFDSCxNQUFNLEdBQUcsS0FBSyxFQUFFLFNBQTRCLEVBQUUsV0FBeUIsRUFBRSxFQUFFO1FBQ3pFLE1BQU0sY0FBYyxHQUFhLEVBQUUsQ0FBQztRQUNwQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ2hDLGNBQWMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztZQUMxQyxjQUFjLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDdkMsSUFBSSxXQUFXLEVBQUUsaUJBQWlCLEVBQUU7Z0JBQ2xD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LEVBQ3BDLE1BQXVCLEVBQ3ZCLEVBQUU7UUFDRixNQUFNLGNBQWMsR0FBRyxpQ0FBaUMsQ0FBQztRQUN6RCxNQUFNLGNBQWMsR0FBRyxtQ0FBbUMsQ0FBQztRQUMzRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hELElBQUksS0FBSyxFQUFFLE1BQU0sSUFBSSxJQUFJLE1BQU0sRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3RCLGtEQUFrRDtnQkFDbEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDOUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2xEO2dCQUNELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQzdDLElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQzlELE1BQU0sQ0FBQyxlQUFlLENBQUMsYUFBYSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUN0RDthQUNGO1NBQ0Y7SUFDSCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCByZWFkbGluZSBmcm9tICdyZWFkbGluZSc7XG5pbXBvcnQge1xuICBCYWNrZW5kRGVwbG95ZXIsXG4gIERlcGxveVByb3BzLFxuICBEZXBsb3lSZXN1bHQsXG4gIERlc3Ryb3lQcm9wcyxcbiAgRGVzdHJveVJlc3VsdCxcbn0gZnJvbSAnLi9jZGtfZGVwbG95ZXJfc2luZ2xldG9uX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgQ0RLRGVwbG95bWVudEVycm9yLCBDZGtFcnJvck1hcHBlciB9IGZyb20gJy4vY2RrX2Vycm9yX21hcHBlci5qcyc7XG5pbXBvcnQge1xuICBCYWNrZW5kSWRlbnRpZmllcixcbiAgdHlwZSBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZExvY2F0b3IsXG4gIENES0NvbnRleHRLZXksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IGRpcm5hbWUgfSBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBDb21tYW5kcyB0aGF0IGNhbiBiZSBpbnZva2VkXG4gKi9cbmVudW0gSW52b2thYmxlQ29tbWFuZCB7XG4gIERFUExPWSA9ICdkZXBsb3knLFxuICBERVNUUk9ZID0gJ2Rlc3Ryb3knLFxuICBTWU5USCA9ICdzeW50aCcsXG59XG5cbi8qKlxuICogSW52b2tlcyBDREsgY29tbWFuZCB2aWEgZXhlY2FcbiAqL1xuZXhwb3J0IGNsYXNzIENES0RlcGxveWVyIGltcGxlbWVudHMgQmFja2VuZERlcGxveWVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSByZWxhdGl2ZUNsb3VkQXNzZW1ibHlMb2NhdGlvbiA9ICcuYW1wbGlmeS9hcnRpZmFjdHMvY2RrLm91dCc7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgaW5zdGFuY2Ugb2YgQ0RLRGVwbG95ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RrRXJyb3JNYXBwZXI6IENka0Vycm9yTWFwcGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZExvY2F0b3I6IEJhY2tlbmRMb2NhdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGFja2FnZU1hbmFnZXJDb250cm9sbGVyOiBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXJcbiAgKSB7fVxuICAvKipcbiAgICogSW52b2tlcyBjZGsgZGVwbG95IGNvbW1hbmRcbiAgICovXG4gIGRlcGxveSA9IGFzeW5jIChiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLCBkZXBsb3lQcm9wcz86IERlcGxveVByb3BzKSA9PiB7XG4gICAgY29uc3QgY2RrQ29tbWFuZEFyZ3M6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGJhY2tlbmRJZC50eXBlID09PSAnc2FuZGJveCcpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0taG90c3dhcC1mYWxsYmFjaycpO1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1tZXRob2Q9ZGlyZWN0Jyk7XG4gICAgICBpZiAoZGVwbG95UHJvcHM/LnNlY3JldExhc3RVcGRhdGVkKSB7XG4gICAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goXG4gICAgICAgICAgJy0tY29udGV4dCcsXG4gICAgICAgICAgYHNlY3JldExhc3RVcGRhdGVkPSR7ZGVwbG95UHJvcHMuc2VjcmV0TGFzdFVwZGF0ZWQuZ2V0VGltZSgpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVwbG95UHJvcHM/LnByb2ZpbGUpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0tcHJvZmlsZScsIGRlcGxveVByb3BzLnByb2ZpbGUpO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IHN5bnRoIHdpdGggdGhlIGJhY2tlbmQgZGVmaW5pdGlvbiBidXQgc3VwcHJlc3MgYW55IGVycm9ycy5cbiAgICAvLyBXZSB3YW50IHRvIHNob3cgZXJyb3JzIGZyb20gdGhlIFRTIGNvbXBpbGVyIHJhdGhlciB0aGFuIHRoZSBFU0J1aWxkIGFzXG4gICAgLy8gVFMgZXJyb3JzIGFyZSBtb3JlIHJlbGV2YW50IChMaWJyYXJ5IHZhbGlkYXRpb25zIGFyZSB0eXBlIHJlbGlhbnQpLlxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHN5bnRoRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudHJ5SW52b2tlQ2RrKFxuICAgICAgICBJbnZva2FibGVDb21tYW5kLlNZTlRILFxuICAgICAgICBiYWNrZW5kSWQsXG4gICAgICAgIHRoaXMuZ2V0QXBwQ29tbWFuZCgpLFxuICAgICAgICBjZGtDb21tYW5kQXJncy5jb25jYXQoJy0tcXVpZXQnKSAvLyBkb24ndCBwcmludCB0aGUgQ0ZOIHRlbXBsYXRlIHRvIHN0ZG91dFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzeW50aEVycm9yID0gZTtcbiAgICB9XG4gICAgLy8gQ0RLIHByaW50cyBzeW50aCB0aW1lIGluIHNlY29uZHMgcm91bmRlZCB0byAyIGRlY2ltYWwgcGxhY2VzLiBIZXJlIHdlIGR1cGxpY2F0ZSB0aGF0IGJlaGF2aW9yLlxuICAgIGNvbnN0IHN5bnRoVGltZVNlY29uZHMgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwKSAvIDEwMDtcblxuICAgIC8vIHRoZW4gcnVuIHR5cGUgY2hlY2tzXG4gICAgYXdhaXQgdGhpcy5pbnZva2VUc2MoZGVwbG95UHJvcHMpO1xuXG4gICAgLy8gSWYgc29tZWhvdyBUU0Mgd2FzIHN1Y2Nlc3NmdWwgYnV0IHN5bnRoIHdhc24ndCwgd2Ugbm93IHRocm93IHRvIHN1cmZhY2UgdGhlIHN5bnRoIGVycm9yXG4gICAgaWYgKHN5bnRoRXJyb3IpIHtcbiAgICAgIHRocm93IHN5bnRoRXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdGhlbiBkZXBsb3kgd2l0aCB0aGUgY2xvdWQgYXNzZW1ibHkgdGhhdCB3YXMgZ2VuZXJhdGVkIGR1cmluZyBzeW50aFxuICAgIGNvbnN0IGRlcGxveVJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5SW52b2tlQ2RrKFxuICAgICAgSW52b2thYmxlQ29tbWFuZC5ERVBMT1ksXG4gICAgICBiYWNrZW5kSWQsXG4gICAgICB0aGlzLnJlbGF0aXZlQ2xvdWRBc3NlbWJseUxvY2F0aW9uLFxuICAgICAgY2RrQ29tbWFuZEFyZ3NcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcGxveW1lbnRUaW1lczoge1xuICAgICAgICBzeW50aGVzaXNUaW1lOiBzeW50aFRpbWVTZWNvbmRzLFxuICAgICAgICB0b3RhbFRpbWU6XG4gICAgICAgICAgc3ludGhUaW1lU2Vjb25kcyArIChkZXBsb3lSZXN1bHQ/LmRlcGxveW1lbnRUaW1lcz8udG90YWxUaW1lIHx8IDApLFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIGNkayBkZXN0cm95IGNvbW1hbmRcbiAgICovXG4gIGRlc3Ryb3kgPSBhc3luYyAoXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBkZXN0cm95UHJvcHM/OiBEZXN0cm95UHJvcHNcbiAgKSA9PiB7XG4gICAgY29uc3QgY2RrQ29tbWFuZEFyZ3M6IHN0cmluZ1tdID0gWyctLWZvcmNlJ107XG4gICAgaWYgKGRlc3Ryb3lQcm9wcz8ucHJvZmlsZSkge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1wcm9maWxlJywgZGVzdHJveVByb3BzLnByb2ZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cnlJbnZva2VDZGsoXG4gICAgICBJbnZva2FibGVDb21tYW5kLkRFU1RST1ksXG4gICAgICBiYWNrZW5kSWQsXG4gICAgICB0aGlzLmdldEFwcENvbW1hbmQoKSxcbiAgICAgIGNka0NvbW1hbmRBcmdzXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgdGhlIGNoaWxkIHByb2Nlc3MgZXhlY3V0b3IuIEhlbHBzIGluIHVuaXQgdGVzdGluZyBhcyBub2RlOnRlc3QgZnJhbWV3b3JrXG4gICAqIGRvZXNuJ3QgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gbW9jayBleHBvcnRlZCBmdW5jdGlvbnMgbGlrZSBgZXhlY2FgIGFzIG9mIHJpZ2h0IG5vdy5cbiAgICovXG4gIGV4ZWN1dGVDb21tYW5kID0gYXN5bmMgKFxuICAgIGNvbW1hbmRBcmdzOiBzdHJpbmdbXSxcbiAgICBvcHRpb25zOiB7IHByaW50U3Rkb3V0OiBib29sZWFuIH0gPSB7IHByaW50U3Rkb3V0OiB0cnVlIH1cbiAgKSA9PiB7XG4gICAgLy8gV2UgbGV0IHRoZSBzdGRvdXQgYW5kIHN0ZGluIGluaGVyaXQgYW5kIHN0cmVhbWVkIHRvIHBhcmVudCBwcm9jZXNzIGJ1dCBwaXBlXG4gICAgLy8gdGhlIHN0ZGVyciBhbmQgdXNlIGl0IHRvIHRocm93IG9uIGZhaWx1cmUuIFRoaXMgaXMgdG8gcHJldmVudCBhY3R1YWxcbiAgICAvLyBhY3Rpb25hYmxlIGVycm9ycyBiZWluZyBoaWRkZW4gYW1vbmcgdGhlIHN0ZG91dC4gTW9yZW92ZXIgZXhlY2EgZXJyb3JzIGFyZVxuICAgIC8vIHVzZWxlc3Mgd2hlbiBjYWxsaW5nIENMSXMgdW5sZXNzIHlvdSBtYWRlIGV4ZWNhIGNhbGxpbmcgZXJyb3IuXG4gICAgbGV0IGFnZ3JlZ2F0ZWRTdGRlcnIgPSAnJztcbiAgICBjb25zdCBhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSgpO1xuICAgIGFnZ3JlZ2F0b3JTdGRlcnJTdHJlYW0uX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgYWdncmVnYXRlZFN0ZGVyciArPSBjaHVuaztcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvY2VzcyA9IHRoaXMucGFja2FnZU1hbmFnZXJDb250cm9sbGVyLnJ1bldpdGhQYWNrYWdlTWFuYWdlcihcbiAgICAgIGNvbW1hbmRBcmdzLFxuICAgICAgcHJvY2Vzcy5jd2QoKSxcbiAgICAgIHtcbiAgICAgICAgc3RkaW46ICdpbmhlcml0JyxcbiAgICAgICAgc3Rkb3V0OiAncGlwZScsXG4gICAgICAgIHN0ZGVycjogJ3BpcGUnLFxuICAgICAgICAvLyBQaXBpbmcgdGhlIG91dHB1dCBieSBkZWZhdWx0IHN0cmlwcyBvZmYgdGhlIGNvbG9yLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgY29sb3IgYmVpbmcgcGlwZWQgdG8gcGFyZW50IHByb2Nlc3MuXG4gICAgICAgIGV4dGVuZEVudjogdHJ1ZSxcbiAgICAgICAgZW52OiB7IEZPUkNFX0NPTE9SOiAnMScgfSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY2hpbGRQcm9jZXNzLnN0ZGVycj8ucGlwZShhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtKTtcblxuICAgIGlmIChvcHRpb25zPy5wcmludFN0ZG91dCkge1xuICAgICAgY2hpbGRQcm9jZXNzLnN0ZG91dD8ucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2RrT3V0cHV0ID0geyBkZXBsb3ltZW50VGltZXM6IHt9IH07XG4gICAgaWYgKGNoaWxkUHJvY2Vzcy5zdGRvdXQpIHtcbiAgICAgIGF3YWl0IHRoaXMucG9wdWxhdGVDREtPdXRwdXRGcm9tU3Rkb3V0KGNka091dHB1dCwgY2hpbGRQcm9jZXNzLnN0ZG91dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNoaWxkUHJvY2VzcztcbiAgICAgIHJldHVybiBjZGtPdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHN3YWxsb3cgZXhlY2EgZXJyb3IgaWYgdGhlIGNkayBjbGkgcmFuIGFuZCBwcm9kdWNlZCBzb21lIHN0ZGVyci5cbiAgICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUgdGhpcyBlcnJvciBpcyBub2lzZShiYXNpY2FsbHkgY2hpbGQgZXhpdGVkIHdpdGggZXhpdCBjb2RlLi4uKVxuICAgICAgLy8gYnViYmxpbmcgdGhpcyB1cCB0byBjdXN0b21lcnMgYWRkIGNvbmZ1c2lvbiAoQ3VzdG9tZXJzIGRvbid0IG5lZWQgdG8ga25vdyB3ZSBhcmUgcnVubmluZyBJUEMgY2FsbHNcbiAgICAgIC8vIGFuZCB0aGVpciBleGl0IGNvZGVzIHByaW50ZWQgd2hpbGUgc2FuZGJveCBjb250aW51ZSB0byBydW4pLiBIZW5jZSB3ZSBleHBsaWNpdGx5IGRvbid0IHBhc3MgZXJyb3IgaW4gdGhlIGNhdXNlXG4gICAgICAvLyByYXRoZXIgdGhyb3cgdGhlIGVudGlyZSBzdGRlcnIgZm9yIGNsaWVudHMgdG8gZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggaXQuXG4gICAgICAvLyBIb3dldmVyIGlmIHRoZSBjZGsgcHJvY2VzcyBkaWRuJ3QgcnVuIG9yIHByb2R1Y2VkIG5vIG91dHB1dCwgdGhlbiB3ZSBoYXZlIG5vdGhpbmcgdG8gZ28gb24gd2l0aC4gU28gd2UgdGhyb3dcbiAgICAgIC8vIHRoaXMgZXJyb3IgdG8gYWlkIGluIHNvbWUgZGVidWdnaW5nLlxuICAgICAgaWYgKGFnZ3JlZ2F0ZWRTdGRlcnIudHJpbSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihhZ2dyZWdhdGVkU3RkZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGdldEFwcENvbW1hbmQgPSAoKSA9PlxuICAgIHRoaXMucGFja2FnZU1hbmFnZXJDb250cm9sbGVyLmdldENvbW1hbmQoW1xuICAgICAgJ3RzeCcsXG4gICAgICB0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpLFxuICAgIF0pO1xuXG4gIHByaXZhdGUgaW52b2tlVHNjID0gYXN5bmMgKGRlcGxveVByb3BzPzogRGVwbG95UHJvcHMpID0+IHtcbiAgICBpZiAoIWRlcGxveVByb3BzPy52YWxpZGF0ZUFwcFNvdXJjZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUNvbW1hbmQoXG4gICAgICAgIFtcbiAgICAgICAgICAndHNjJyxcbiAgICAgICAgICAnLS1zaG93Q29uZmlnJyxcbiAgICAgICAgICAnLS1wcm9qZWN0JyxcbiAgICAgICAgICBkaXJuYW1lKHRoaXMuYmFja2VuZExvY2F0b3IubG9jYXRlKCkpLFxuICAgICAgICBdLFxuICAgICAgICB7IHByaW50U3Rkb3V0OiBmYWxzZSB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB3ZSBjYW5ub3QgbG9hZCB0cyBjb25maWcsIHR1cm4gb2ZmIHR5cGUgY2hlY2tpbmdcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUNvbW1hbmQoW1xuICAgICAgICAndHNjJyxcbiAgICAgICAgJy0tbm9FbWl0JyxcbiAgICAgICAgJy0tc2tpcExpYkNoZWNrJyxcbiAgICAgICAgLy8gcG9pbnRpbmcgdGhlIHByb2plY3QgYXJnIHRvIHRoZSBhbXBsaWZ5IGJhY2tlbmQgZGlyZWN0b3J5IHdpbGwgdXNlIHRoZSB0c2NvbmZpZyBwcmVzZW50IGluIHRoYXQgZGlyZWN0b3J5XG4gICAgICAgICctLXByb2plY3QnLFxuICAgICAgICBkaXJuYW1lKHRoaXMuYmFja2VuZExvY2F0b3IubG9jYXRlKCkpLFxuICAgICAgXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcjxDREtEZXBsb3ltZW50RXJyb3I+KFxuICAgICAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZTogJ1R5cGVTY3JpcHQgdmFsaWRhdGlvbiBjaGVjayBmYWlsZWQuJyxcbiAgICAgICAgICByZXNvbHV0aW9uOlxuICAgICAgICAgICAgJ0ZpeCB0aGUgc3ludGF4IGFuZCB0eXBlIGVycm9ycyBpbiB5b3VyIGJhY2tlbmQgZGVmaW5pdGlvbi4nLFxuICAgICAgICB9LFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGNhbGxzIGludm9rZUNESyBhbmQgd3JhcCBpdCBpbiBhIHRyeSBjYXRjaFxuICAgKi9cbiAgcHJpdmF0ZSB0cnlJbnZva2VDZGsgPSBhc3luYyAoXG4gICAgaW52b2thYmxlQ29tbWFuZDogSW52b2thYmxlQ29tbWFuZCxcbiAgICBiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLFxuICAgIGFwcEFyZ3VtZW50OiBzdHJpbmcsXG4gICAgYWRkaXRpb25hbEFyZ3VtZW50cz86IHN0cmluZ1tdXG4gICk6IFByb21pc2U8RGVwbG95UmVzdWx0IHwgRGVzdHJveVJlc3VsdD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnZva2VDZGsoXG4gICAgICAgIGludm9rYWJsZUNvbW1hbmQsXG4gICAgICAgIGJhY2tlbmRJZCxcbiAgICAgICAgYXBwQXJndW1lbnQsXG4gICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHNcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyB0aGlzLmNka0Vycm9yTWFwcGVyLmdldEFtcGxpZnlFcnJvcihlcnIgYXMgRXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBDREsgY29tbWFuZFxuICAgKi9cbiAgcHJpdmF0ZSBpbnZva2VDZGsgPSBhc3luYyAoXG4gICAgaW52b2thYmxlQ29tbWFuZDogSW52b2thYmxlQ29tbWFuZCxcbiAgICBiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLFxuICAgIGFwcEFyZ3VtZW50OiBzdHJpbmcsXG4gICAgYWRkaXRpb25hbEFyZ3VtZW50cz86IHN0cmluZ1tdXG4gICk6IFByb21pc2U8RGVwbG95UmVzdWx0IHwgRGVzdHJveVJlc3VsdD4gPT4ge1xuICAgIC8vIEJhc2ljIGFyZ3NcbiAgICBjb25zdCBjZGtDb21tYW5kQXJncyA9IFtcbiAgICAgICdjZGsnLFxuICAgICAgaW52b2thYmxlQ29tbWFuZC50b1N0cmluZygpLFxuICAgICAgLy8gVGhpcyBpcyB1bmZvcnR1bmF0ZS4gQ0RLIHdyaXRlcyBldmVyeXRoaW5nIHRvIHN0ZGVyciB3aXRob3V0IGAtLWNpYCBmbGFnIGFuZCB3ZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGUgdHdvLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvNzcxNyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgJy0tY2knLFxuICAgICAgJy0tYXBwJyxcbiAgICAgIGFwcEFyZ3VtZW50LFxuICAgICAgJy0tYWxsJyxcbiAgICAgICctLW91dHB1dCcsXG4gICAgICB0aGlzLnJlbGF0aXZlQ2xvdWRBc3NlbWJseUxvY2F0aW9uLFxuICAgIF07XG5cbiAgICAvLyBBZGQgY29udGV4dCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICBjZGtDb21tYW5kQXJncy5wdXNoKFxuICAgICAgJy0tY29udGV4dCcsXG4gICAgICBgJHtDREtDb250ZXh0S2V5LkJBQ0tFTkRfTkFNRVNQQUNFfT0ke2JhY2tlbmRJZC5uYW1lc3BhY2V9YCxcbiAgICAgICctLWNvbnRleHQnLFxuICAgICAgYCR7Q0RLQ29udGV4dEtleS5CQUNLRU5EX05BTUV9PSR7YmFja2VuZElkLm5hbWV9YFxuICAgICk7XG5cbiAgICBpZiAoYmFja2VuZElkLnR5cGUgIT09ICdzYW5kYm94Jykge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1yZXF1aXJlLWFwcHJvdmFsJywgJ25ldmVyJyk7XG4gICAgfVxuXG4gICAgY2RrQ29tbWFuZEFyZ3MucHVzaChcbiAgICAgICctLWNvbnRleHQnLFxuICAgICAgYCR7Q0RLQ29udGV4dEtleS5ERVBMT1lNRU5UX1RZUEV9PSR7YmFja2VuZElkLnR5cGV9YFxuICAgICk7XG5cbiAgICBpZiAoYWRkaXRpb25hbEFyZ3VtZW50cykge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCguLi5hZGRpdGlvbmFsQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlQ29tbWFuZChjZGtDb21tYW5kQXJncyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBwb3B1bGF0ZUNES091dHB1dEZyb21TdGRvdXQgPSBhc3luYyAoXG4gICAgb3V0cHV0OiBEZXBsb3lSZXN1bHQgfCBEZXN0cm95UmVzdWx0LFxuICAgIHN0ZG91dDogc3RyZWFtLlJlYWRhYmxlXG4gICkgPT4ge1xuICAgIGNvbnN0IHJlZ2V4VG90YWxUaW1lID0gL+KcqCB7Mn1Ub3RhbCB0aW1lOiAoXFxkKlxcLipcXGQqKXMuKi87XG4gICAgY29uc3QgcmVnZXhTeW50aFRpbWUgPSAv4pyoIHsyfVN5bnRoZXNpcyB0aW1lOiAoXFxkKlxcLipcXGQqKXMvO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRsaW5lLmNyZWF0ZUludGVyZmFjZShzdGRvdXQpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgbGluZSBvZiByZWFkZXIpIHtcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCfinKgnKSkge1xuICAgICAgICAvLyBHb29kIGNoYW5jZSB0aGF0IGl0IGNvbnRhaW5zIHRpbWluZyBpbmZvcm1hdGlvblxuICAgICAgICBjb25zdCB0b3RhbFRpbWUgPSBsaW5lLm1hdGNoKHJlZ2V4VG90YWxUaW1lKTtcbiAgICAgICAgaWYgKHRvdGFsVGltZSAmJiB0b3RhbFRpbWUubGVuZ3RoID4gMSAmJiAhaXNOYU4oK3RvdGFsVGltZVsxXSkpIHtcbiAgICAgICAgICBvdXRwdXQuZGVwbG95bWVudFRpbWVzLnRvdGFsVGltZSA9ICt0b3RhbFRpbWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ludGhUaW1lID0gbGluZS5tYXRjaChyZWdleFN5bnRoVGltZSk7XG4gICAgICAgIGlmIChzeW50aFRpbWUgJiYgc3ludGhUaW1lLmxlbmd0aCA+IDEgJiYgIWlzTmFOKCtzeW50aFRpbWVbMV0pKSB7XG4gICAgICAgICAgb3V0cHV0LmRlcGxveW1lbnRUaW1lcy5zeW50aGVzaXNUaW1lID0gK3N5bnRoVGltZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiJdfQ==